"""
 Произвести вычисления как в пункте 2, но с вычислением intercept. Учесть, что
изменение коэффициентов должно производиться
на каждом шаге одновременно (то есть изменение одного коэффициента не должно
влиять на изменение другого во время одной итерации).
"""
import numpy

ks = numpy.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])  # y
zp = numpy.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])  # x
alfa = 1e-4
B_1 = 2
B_0 = 400
n = len(zp)
for i in range(750000):
    Y_pred = numpy.array([])
    for x in zp:
        Y_pred = numpy.append(Y_pred, B_0 + (B_1 * x))
    B_0 = B_0 - (alfa * ((1 / n) * numpy.sum(Y_pred - ks)))
    B_1 = B_1 - (alfa * ((1 / n) * numpy.sum((Y_pred - ks) * zp)))
    if i % 75000 == 0:
        print(f"B1 = {B_1}, B0 = {B_0}")
"""
B1 = 3.3028500000000003, B0 = 400.01071
B1 = 2.6690475044897988, B0 = 437.58690782953164
B1 = 2.627776800909533, B0 = 443.19400355518945
B1 = 2.62161884431586, B0 = 444.0306321827586
B1 = 2.6207000223399737, B0 = 444.1554646262767
B1 = 2.620562925916761, B0 = 444.174090738795
B1 = 2.620542469909219, B0 = 444.17686992069656
B1 = 2.6205394176906602, B0 = 444.1772845993948
B1 = 2.620538962272484, B0 = 444.17734647314745
B1 = 2.620538894320039, B0 = 444.1773557052621
"""
